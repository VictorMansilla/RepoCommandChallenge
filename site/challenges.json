[
    {
        "slug": "12days_1",
        "version": 1,
        "disp_title": "A list of files",
        "dir": "night_before_christmas",
        "emoji": "12days/12days_1",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the first day of Shell my true love gave to me<br />\nA list of files in the directory tree ...\n</div>\n",
        "learn": "You've stumbled upon a festive adventure where you need to type single commands into your browser to get Christmas presents!\nAs a reward for your efforts, you might learn a little bit about the command line.\n\nOn just about every Unix and Unix-like operating systems there is a command named `ls`. <br />\n`ls` is short for \"list\" and can be used to list files in your current working directory.\n\nTry sending the command `ls` in the command box to list all files in the directory.\n",
        "disp_learn": true,
        "example": "ls",
        "expected_output": {
            "lines": [
                "night-before-christmas.txt"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_2",
        "version": 1,
        "disp_title": "Two lines a-laughing",
        "dir": "night_before_christmas",
        "emoji": "12days/12days_2",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the second day of Shell my true love gave to me<br />\nTwo lines a-laughing ...\n</div>\n\n---\n_Hint: look for lines that contain the string \"laugh\"_<br /><br />\n_If you aren't sure what to do, expand the \"learn\" section above._<br />\n_You can also view user solutions by expanding \"View Solutions\" above_\n",
        "learn": "What's so funny? Let's look for lines in our Christmas poem that are laughing.\n\n`grep` is the most common command-line utility for extracting text from a file.<br />\nThe syntax of the command is `grep PATTERN <file>`.<br />\n`PATTERN` is a string, and refers to a [basic regular expression](https://www.gnu.org/software/sed/manual/html_node/BRE-syntax.html).<br />\nAll you need to know for now is to set `PATTERN` to the string you are looking for.\n\nIn this example you might try:\n\n```\ngrep laugh night-before-christmas.txt\n```\n\nWhich will print every single line that contains the string \"laugh\".<br />\nThere are many options for the `grep` command, for example to do a case-insensitive search you would type:\n\n```\ngrep -i laugh night-before-christmas.txt\n```\n\nTo see all available options check out the man page by sending the command `man grep` or the help `grep --help`.\n",
        "example": "grep laugh night-before-christmas.txt",
        "expected_output": {
            "lines": [
                "That shook when he laughed, like a bowlful of jelly.",
                "And I laughed when I saw him, in spite of myself;"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_3",
        "version": 1,
        "disp_title": "Three lines at the beginning",
        "dir": "night_before_christmas",
        "emoji": "12days/12days_3",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the third day of Shell my true love gave to me<br />\nThree lines at the beginning ...\n</div>\n",
        "learn": "When you have a text file, it's common to only need to see the top N lines.\nIncluded in most Unix-like systems is a utility named `head`.\nBy default, it will display the first 10 lines of the file.\n\nTo display the first 3 lines, you will need to use the option `-n 3`.\n\nTry sending the command:\n\n```\nhead -n 3 night-before-christmas.txt\n```\n",
        "example": "head -3 night-before-christmas.txt",
        "expected_output": {
            "lines": [
                "'Twas the night before Christmas, when all through the house",
                "Not a creature was stirring, not even a mouse;",
                "The stockings were hung by the chimney with care"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_4",
        "version": 1,
        "disp_title": "Four lines at the end",
        "dir": "night_before_christmas",
        "emoji": "12days/12days_4",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the fourth day of Shell my true love gave to me<br />\nFour lines at the end ...\n</div>\n",
        "learn": "Just like we needed to look at the beginning lines on day three, a utility called `tail` can be used to look at the bottom N lines.\nBy default it will display the last 10 lines so like before you will need to use the `-n` option.\n\n```\ntail -n 4 night-before-christmas.txt\n```\n",
        "example": "tail -4 night-before-christmas.txt",
        "expected_output": {
            "lines": [
                "He sprang to his sleigh, to his team gave a whistle,",
                "And away they all flew like the down of a thistle.",
                "But I heard him exclaim, ere he drove out of sight,",
                "\"Happy Christmas to all, and to all a good-night.\""
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_5",
        "version": 1,
        "disp_title": "Five lines that start with \"the\"",
        "dir": "night_before_christmas",
        "emoji": "12days/12days_5",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the fifth day of Shell my true love gave to me<br />\nFive lines that start with \"the\" ...\n</div>\n",
        "learn": "We already used `grep` to extract a string from a file earlier so if you were thinking we would use `grep` again you are on the right track!\n\nHere we want to find all lines that start with the word \"the\".\nOne way you could do this is look for a capital \"T\" since the beginning of every sentence is capatilized.<br />\nSince `grep` is case sensitive by default, one way would be to search for the string `The`\n\nWe mentioned early that the PATTERN in `grep PATTERN <file>` refers to a [basic regular expression](https://www.gnu.org/software/sed/manual/html_node/BRE-syntax.html).<br />\nThis allows to do more than simple string matches by using the basic regular expression syntax.<br />\nOne example is the `^` character which will anchor the search to the start of every string.<br />\nThis type of character is called a [regex anchor](https://www.regular-expressions.info/anchors.html).<br />\n\nTo do a case-insenstive search for the word `the` but only match it at the _beginning_ of every line, you will need to use a combination of `-i` for case insenstive match and an `^` anchor.\n\nFor example:\n\n```\ngrep -i \"^the\" night-before-christmas.txt\n```\n\nTry it below!\n",
        "example": "grep -i \"^the\" night-before-christmas.txt",
        "expected_output": {
            "lines": [
                "The stockings were hung by the chimney with care",
                "The children were nestled all snug in their beds,",
                "The moon on the breast of the new-fallen snow",
                "The prancing and pawing of each little hoof.",
                "The stump of a pipe he held tight in his teeth,"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_6",
        "version": 1,
        "disp_title": "Six lines that are exciting!",
        "dir": "night_before_christmas",
        "emoji": "12days/12days_6",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the sixth day of Shell my true love gave to me<br />\nSix lines that are exciting! ...\n</div>\n\n---\n_Hint: Exciting lines end with \"!\"_\n",
        "learn": "To find \"exciting\" lines we want to only print lines that end with a `!` character.<br />\nJust like how previously we learned that regular expression syntax can match strings with an anchor at the beginning of the line we can use `$` to anchor the match at the end.\n\n```\ngrep '!$' night-before-christmas.txt\n```\n\nOne important thing to be aware of is that the character `!` is a [special character](https://www.oreilly.com/library/view/learning-the-bash/1565923472/ch01s09.html) for the shell.<br />\nTo ensure that this works correctly you will need to either use single-quotes like above, or escape it with a `\\`:\n\n```\ngrep \\!$ night-before-christmas.txt\n```\n",
        "example": "grep \\!$ night-before-christmas.txt",
        "expected_output": {
            "lines": [
                "Now, Dasher! now, Dancer! now, Prancer and Vixen!",
                "On, Comet! on, Cupid! on, Donder and Blitzen!",
                "To the top of the porch! to the top of the wall!",
                "Now dash away! dash away! dash away all!",
                "His eyes--how they twinkled! his dimples how merry!",
                "His cheeks were like roses, his nose like a cherry!"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_7",
        "version": 1,
        "disp_title": "Seven files that start with Santa",
        "dir": "santa",
        "emoji": "12days/12days_7",
        "completions": [
            "night-before-christmas.txt"
        ],
        "description": "<div class=\"twelve-days\">\nOn the seventh day of Shell my true love gave to me<br />\nSeven files that start with \"Santa\" ...\n</div>\n",
        "learn": "Now there are more than just one file in the working directory. Like the first day, we will need to use the `ls` command to list them.<br />\nUnlike before, we need to limit the output to only files that begin with the string \"Santa\".<br />\nTo do this, we will need to use a feature of most shells that is called wildcarding or [globbing](https://tldp.org/LDP/abs/html/globbingref.html).\n\nTo create a wildcard, you will use the `*` character which will match zero or more characters after the string.<br />\nFor example, to match anything that starts with the string \"Santa\" you will need to send:\n\n```\nls Santa*\n```\n\nIf you wanted to list files that start with \"Santa\" or \"santa\" there is another feature you can use that can match multiple characters called [ranges](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_03.html).<br />\nFor example:\n\n```\nls [Ss]anta*\n```\n\nWill match both files named `Santa's hat` and `santa's toys`.\n",
        "example": "ls -1  [Ss]anta*",
        "expected_output": {
            "order": false,
            "re_sub": [
                "^.*\\/",
                ""
            ],
            "lines": [
                "Santa's beard",
                "Santa's belly",
                "Santa's hat",
                "Santa's reindeer",
                "Santa's sleigh",
                "Santa's toys",
                "Santa's village"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_8",
        "version": 2,
        "disp_title": "Eight elves",
        "dir": "elves",
        "emoji": "12days/12days_8",
        "completions": [
            "Elves",
            "Workshop",
            "Hermey",
            "Pepper Minstix",
            "Shinny Upatree",
            "Buddy",
            "Wunorse Openslae",
            "Alabaster Snowball",
            "Bushy Evergreen",
            "Sugarplum Mary"
        ],
        "description": "<div class=\"twelve-days\">\nOn the eighth day of Shell my true love gave to me<br />\nEight elves in Santa's Workhop/ ...\n</div>\n\n---\n_Hint: Try finding files named after Elves and moving them to the Workshop/ directory._\n",
        "learn": "The elves are lost and only you can help them get back into Santa's workshop!\n\nYou can see where they are by sending the command `ls Elves/`. This will list all the files in the \"Elves/\" directory.\nTo move them to the `Workhop/` we will need to use the `mv` command and the `*` wildcard that was used on Day 7.\n\nThe `mv` command will move one more more files from one location to a new one. <br />\nIf you specify multiple files, all the files will be moved to the last argument which is the destination.\n\nFor example:\n\n```\nmv file1 file2 file3 destination/\n```\nWill move all three files to the folder named `destination/`\n\nTo move every file in in `Elves/` we can use a wildcard `Elves/*`, and move them by sending the following command:\n\n```\nmv Elves/* Workshop/\n```\n",
        "example": "mv Elves/* Workshop/",
        "expected_failures": [
            "echo",
            "cp Elves/* Workshop/"
        ],
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_9",
        "version": 1,
        "dir": "nine_reindeer",
        "emoji": "12days/12days_9",
        "completions": [
            "Vixen",
            "North Pole",
            "Stable",
            "Prancer",
            "Comet",
            "Cupid",
            "Dancer",
            "Santa's Village",
            "Santa's Workshop",
            "Rudolph",
            "Dasher",
            "Blixem",
            "Dunder"
        ],
        "disp_title": "Nine Reindeer",
        "description": "<div class=\"twelve-days\">\nOn the ninth day of Shell my true love gave to me<br />\nNine names of Santa's Reindeer ...\n</div>\n",
        "learn": "Santa's nine Reindeer are lost in sub-directories, can you find them?\n\nHere we introduce a common utility called `find` which as you can probably guess, is\nused to find files. The Reindeer are hiding in sub-directories, to search for them\nin the current directory we use `.` as the first option to `find`. `.` is just another\nway of specifying the current working directory that you are in.\n\nTry sending:\n\n```\nfind .\n```\n\nThis will find both directories **and** files which is not what we want. <br />\nIn order to display only files, you will need to use the `-type f` argument to `find`:\n\n```\nfind . -type f\n```\n",
        "example": "find . -type f",
        "expected_output": {
            "order": false,
            "re_sub": [
                "^.*\\/",
                ""
            ],
            "lines": [
                "Dasher",
                "Rudolph",
                "Dancer",
                "Prancer",
                "Vixen",
                "Comet",
                "Cupid",
                "Dunder",
                "Blixem"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_10",
        "version": 1,
        "dir": "lords",
        "emoji": "12days/12days_10",
        "completions": [
            "lords.txt"
        ],
        "disp_title": "Ten Lords",
        "description": "<div class=\"twelve-days\">\nOn the tenth day of Shell my true love gave to me<br />\nTen Lords by their names sorted ...\n</div>\n",
        "learn": "The Ten Lords are all mixed up!\n\nSorting is something we do often on the command line.\nThere is a file named `lords.txt` that contains a list of lords. We can\nuse the command `sort` to sort the contents and print them, by default\nit will sort the file in dictionary order.\n\n```\nsort lords.txt\n```\n",
        "example": "sort lords.txt",
        "expected_output": {
            "lines": [
                "Lord Asriel",
                "Lord Buckethead",
                "Lord Drinian",
                "Lord Elrond",
                "Lord Farquaad",
                "Lord Gendry",
                "Lord Glenarvan",
                "Lord Macduff",
                "Lord Palpatine",
                "Lord Snooty"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_11",
        "version": 1,
        "dir": "pipers",
        "emoji": "12days/12days_11",
        "completions": [
            "place-for-pipers",
            "01",
            "02",
            "03",
            "04",
            "05",
            "06",
            "07",
            "08",
            "09",
            "10",
            "11",
            "piper",
            "not-a-piper"
        ],
        "disp_title": "Eleven Pipers",
        "description": "<div class=\"twelve-days\">\nOn the eleventh day of Shell my true love gave to me<br />\nEleven lines with pipers ♫ piping ♫ ...\n</div>\n",
        "learn": "The pipers are playing their pipes but also other music, can you print the piping music?\n\nHere we find ourselves in a directory with files named `piper`, each file\nwith one line matching the string \"♫ piping ♫\". <br />\nTo only output the lines that match \"♫ piping ♫\" we will need to first find\nthe files that contain the string, and then output their contents.\n\nEarlier we used the `find` command to find files, here we will use it again to\nfind files named `piper`:\n\n```\nfind . -name \"piper\" -type f\n```\n\nTo look for specific strings in each `find` result, the `-exec` can be used to execute a\ncommand for every file found. The special string `{}` can be used as a substitute for the\nfilename. For example:\n\n```\nfind . -name \"piper\" -type f -exec grep piping {} \\;\n```\n\nwill search for the string \"piping\" and execute `grep` in every file that find returns.\nThe `\\;` is an escaped `;` that ends the command that is executed.\n\nThere are a lot of different ways to get the same result, see the solutions for more examples.\nIt's even possible to play the pipers piping using a pipe!\n",
        "example": "find . -name \"piper\" -exec grep piping {} \\;",
        "expected_output": {
            "lines": [
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫",
                "♫ piping ♫"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "12days_12",
        "disp_learn": true,
        "version": 1,
        "dir": "twelve_days_of_shell",
        "emoji": "12days/12days_12",
        "completions": [
            "twelve-days-of-shell.txt"
        ],
        "disp_title": "Twelve days of Shell",
        "description": "<div class=\"twelve-days\">\nOn the twelfth day of Shell my true love gave to me<br />\nTwelve Days of Shell on the terminal!\n</div>\n",
        "learn": "We have reached the twelfth day of Shell!<br />\nFor the final day all you need to do is print out the contents of `twelve-days-of-shell.txt`.\n\nIf you enjoyed these exercises [follow us on twitter](https://twitter.com/thecmdchallenge)\nor try more [command line challenges](https://cmdchallenge.com)!\n",
        "example": "cat twelve-days-of-shell.txt",
        "expected_output": {
            "lines": [
                "🥁 🎵 🎶 🎵 🥁",
                "On the twelfth day of Shell my true love gave to me",
                "Twelve days of Shell on the terminal",
                "Eleven lines with pipers ♫ piping ♫",
                "Ten lords by their names sorted",
                "Nine names of Santa's reindeer",
                "Eight elves in Santa's Workhop/",
                "Seven files that start with \"Santa\"",
                "Six lines that are exciting!",
                "Five lines that start with \"the\"",
                "Four lines at the end",
                "Three lines at the beginning",
                "Two lines a-laughing",
                "And a list of files in the directory tree",
                "🥁 🎵 🎶 🎵 🥁"
            ]
        },
        "tags": [
            "12days"
        ]
    },
    {
        "slug": "oops_cwd",
        "emoji": "emojis/1F62D",
        "disp_title": "current working directory",
        "version": 2,
        "description": "A process on this computer managed to delete all of the files in\nthe /bin and /usr/bin directories!\n\n---\nThe good news is that you still have a shell prompt, the bad news\nis that you are only able to execute one command to complete each challenge.\n\nFor now, all you need to do is figure out where you are,\nprint the current working directory.\n",
        "example": "pwd",
        "expected_output": {
            "lines": [
                "/var/challenges/oops_cwd"
            ]
        },
        "img": "cmd-no-bin",
        "tags": [
            "oops"
        ]
    },
    {
        "slug": "oops_list_files",
        "disp_title": "list files",
        "version": 3,
        "emoji": "emojis/1F92F",
        "description": "Great, now that you know which directory you are in, you want to see what else\nis here. List all of the files on a single line, in the current working directory.\n\nHint: You won't be able to use the `ls` command, instead you will need to use\na bash builtin\n",
        "expected_failures": [
            "echo \"another-file.txt my-dissertation.txt\""
        ],
        "expected_output": {
            "lines": [
                "another-file.txt my-dissertation.txt"
            ]
        },
        "example": "echo *",
        "img": "cmd-no-bin",
        "tags": [
            "oops"
        ]
    },
    {
        "slug": "oops_print_file_contents",
        "disp_title": "print file contents",
        "version": 2,
        "emoji": "emojis/1F630",
        "description": "Oh no! You now remember there is a very important file in this directory.\n\nDisplay its contents before the data is lost for forever!\n",
        "completions": [
            "my-dissertation.txt"
        ],
        "example": "while read x; do echo $x; done < my-dissertation.txt",
        "expected_output": {
            "lines": [
                "Rooter: A Methodology for the Typical Unification",
                "",
                "of Access Points and Redundancy",
                "",
                "Jeremy Stribling, Daniel Aguayo and Maxwell Krohn",
                "",
                "ABSTRACT",
                "",
                "Many physicists would agree that, had it not been for",
                "congestion control, the evaluation of web browsers might never",
                "have occurred. In fact, few hackers worldwide would disagree",
                "with the essential uniﬁcation of voice-over-IP and public-",
                "private key pair. In order to solve this riddle, we conﬁrm that",
                "SMPs can be made stochastic, cacheable, and interposable.",
                "..."
            ]
        },
        "img": "cmd-no-bin",
        "tags": [
            "oops"
        ]
    },
    {
        "slug": "oops_print_process",
        "disp_title": "print process name",
        "version": 4,
        "emoji": "emojis/1F627",
        "description": "You know there is a process on machine that is deleting files, the first thing\nyou want to do is identify the name of it. Print the name of the process\n\nHint: process information is stored in /proc, maybe there is a something there\nthat will help?\n",
        "example": "echo \"$(</proc/42/cmdline)\"",
        "expected_output": {
            "ignore_non_matching": true,
            "lines": [
                "oops-this-will-delete-bin-dirs"
            ]
        },
        "img": "cmd-no-bin",
        "tags": [
            "oops"
        ]
    },
    {
        "slug": "oops_kill_a_process",
        "disp_title": "kill a process",
        "version": 2,
        "emoji": "emojis/1F625",
        "description": "You are doing great!\n\nYou managed to save your important file.\nNow that you know the process name\nit will be good to kill it before it does any more damanage.\n\nKill the running process\n",
        "example": "kill -9 42",
        "expected_failures": [
            "echo"
        ],
        "img": "cmd-no-bin",
        "tags": [
            "oops"
        ]
    },
    {
        "slug": "hello_world",
        "emoji": "emojis/1F40C",
        "disp_title": "hello world",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Tu primer desafío es imprimir \"hola mundo\" en la terminal con un solo comando.\n\nSugerencia: Hay muchas maneras de imprimir texto en la línea de comandos, una de ellas es con el comando 'echo'.\n¡Pruébalo a continuación y buena suerte!\n",
        "completions": [
            "place your advertisement here!"
        ],
        "example": "echo 'hola mundo",
        "expected_failures": [
            "echo \"nope\""
        ],
        "expected_output": {
            "lines": [
                "hola mundo"
            ]
        }
    },
    {
        "slug": "current_working_directory",
        "emoji": "emojis/1F98B",
        "disp_title": "cwd",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprimir el directorio de trabajo actual.\n",
        "example": "pwd",
        "expected_failures": [
            "echo \"nope\""
        ],
        "expected_output": {
            "lines": [
                "/var/challenges/current_working_directory"
            ]
        }
    },
    {
        "slug": "list_files",
        "emoji": "emojis/1F41B",
        "disp_title": "list files",
        "version": 8,
        "author": "cmdchallenge",
        "description": "Lista los nombres de todos los archivos en el directorio actual, un archivo por línea.\n",
        "example": "ls",
        "expected_output": {
            "order": false,
            "lines": [
                "01-take.txt",
                "02-the.txt",
                "03-command.txt",
                "04-challenge.txt"
            ]
        },
        "expected_failures": [
            "echo -e \"01-take.txt\\n02-the.txt\\n03-command.txt\\n04-challenge.txt\""
        ]
    },
    {
        "slug": "print_file_contents",
        "emoji": "emojis/1F41C",
        "disp_title": "file contents",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Hay un archivo llamado `access.log` en el directorio actual. Imprima el contenido.\n",
        "completions": [
            "access.log"
        ],
        "example": "cat access.log",
        "expected_output": {
            "lines": [
                "163.56.115.58 - - [09/Jan/2017:22:29:57 +0100] \"GET /posts/2/display HTTP/1.0\" 200 3240",
                "75.113.188.234 - - [09/Jan/2017:22:30:43 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 1116",
                "69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] \"GET /pages/create HTTP/1.0\" 500 3471",
                "225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 500 2477",
                "207.243.19.2 - - [09/Jan/2017:22:38:03 +0100] \"GET /bar/create HTTP/1.0\" 200 1116",
                "199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] \"GET /posts/1/display HTTP/1.0\" 200 2477",
                "55.74.240.123 - - [09/Jan/2017:22:44:25 +0100] \"POST /posts/1/display HTTP/1.0\" 200 3471",
                "251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 2477",
                "101.163.230.250 - - [09/Jan/2017:22:52:31 +0100] \"DELETE /posts/2/display HTTP/1.0\" 404 2477",
                "200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 3471"
            ]
        }
    },
    {
        "slug": "last_lines",
        "emoji": "emojis/1F578",
        "version": 5,
        "author": "cmdchallenge",
        "disp_title": "last lines",
        "description": "Imprimir las últimas 5 líneas de \"access.log\".\n",
        "completions": [
            "access.log"
        ],
        "example": "tail -n 5 access.log",
        "expected_output": {
            "lines": [
                "199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] \"GET /posts/1/display HTTP/1.0\" 200 2477",
                "55.74.240.123 - - [09/Jan/2017:22:44:25 +0100] \"POST /posts/1/display HTTP/1.0\" 200 3471",
                "251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 2477",
                "101.163.230.250 - - [09/Jan/2017:22:52:31 +0100] \"DELETE /posts/2/display HTTP/1.0\" 404 2477",
                "200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 3471"
            ]
        }
    },
    {
        "slug": "create_file",
        "emoji": "emojis/1F433",
        "disp_title": "Create a file",
        "version": 2,
        "author": "cmdchallenge",
        "description": "Crea un archivo vacío llamado `take-the-command-challenge` en el directorio de trabajo actual.\n",
        "completions": [
            "take-the-command-challenge"
        ],
        "example": "touch take-the-command-challenge",
        "expected_failures": [
            "echo",
            "echo ' ' > take-the-command-challenge"
        ]
    },
    {
        "slug": "create_directory",
        "emoji": "emojis/1F40B",
        "disp_title": "Create a directory",
        "version": 2,
        "author": "cmdchallenge",
        "description": "Crea un directorio llamado `tmp/files` en el directorio de trabajo actual\n---\n_Sugerencia: El directorio \"`tmp/`\" no existe, con un comando necesitas crear tanto \"`tmp/`\" como \"`tmp/files`\"_\n",
        "completions": [
            "take-the-command-challenge",
            "tmp/files"
        ],
        "example": "mkdir -p tmp/files",
        "expected_failures": [
            "mkdir tmp | mkdir tmp/files",
            "echo"
        ]
    },
    {
        "slug": "copy_file",
        "emoji": "emojis/1F42C",
        "disp_title": "copy file",
        "version": 3,
        "author": "cmdchallenge",
        "description": "Copiar el archivo llamado `take-the-command-challenge` al directorio `tmp/files`\n",
        "completions": [
            "take-the-command-challenge",
            "tmp/files"
        ],
        "example": "cp take-the-command-challenge tmp/files/.",
        "expected_failures": [
            "echo",
            "mv take-the-command-challenge tmp/files"
        ]
    },
    {
        "slug": "move_file",
        "emoji": "emojis/1F41F",
        "disp_title": "move file",
        "version": 1,
        "author": "cmdchallenge",
        "description": "Mueva el archivo llamado `take-the-command-challenge` al directorio `tmp/files`\n",
        "completions": [
            "take-the-command-challenge",
            "tmp/files"
        ],
        "example": "mv take-the-command-challenge tmp/files/.",
        "expected_failures": [
            "echo"
        ]
    },
    {
        "slug": "create_symlink",
        "emoji": "emojis/1F420",
        "disp_title": "create symlink",
        "version": 1,
        "author": "cmdchallenge",
        "description": "Un enlace simbólico es un tipo de archivo que hace referencia a otro archivo.\n\nCrea un enlace simbólico llamado `take-the-command-challenge` que apunte al\narchivo `tmp/files/take-the-command-challenge`.\n",
        "completions": [
            "take-the-command-challenge",
            "tmp/files/take-the-command-challenge"
        ],
        "example": "ln -s /var/challenges/create_symlink/tmp/files/take-the-command-challenge",
        "expected_failures": [
            "echo"
        ]
    },
    {
        "slug": "delete_files",
        "emoji": "emojis/1F421",
        "disp_title": "delete files",
        "version": 7,
        "author": "cmdchallenge",
        "description": "Elimine todos los archivos en este directorio del desafío, incluidos todos los subdirectorios y sus contenidos.\n---\n_Sugerencia: Hay archivos y directorios que comienzan con un punto \"`.`\", \"`rm -rf *`\" no funcionará aquí!_\n",
        "example": "find . -delete",
        "expected_failures": [
            "find . -exec rm {} \\;",
            "rm -rf /var/challenges/delete_files"
        ]
    },
    {
        "slug": "remove_files_with_extension",
        "emoji": "emojis/1F43A",
        "version": 6,
        "author": "cmdchallenge",
        "disp_title": "remove files with extension",
        "description": "Hay archivos en este desafío con diferentes extensiones.\nElimine todos los archivos con la extensión .doc de forma recursiva en el directorio de trabajo actual.\n",
        "example": "rm **/*.doc",
        "expected_failures": [
            "echo",
            "rm -R .* *"
        ]
    },
    {
        "slug": "find_string_in_a_file",
        "emoji": "emojis/1F41D",
        "disp_title": "find string",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Hay un archivo llamado `access.log` en el directorio de trabajo actual. Imprima todas las líneas de este archivo que contengan la cadena \"GET\".\n",
        "completions": [
            "access.log"
        ],
        "example": "grep 'GET' access.log",
        "expected_output": {
            "lines": [
                "163.56.115.58 - - [09/Jan/2017:22:29:57 +0100] \"GET /posts/2/display HTTP/1.0\" 200 3240",
                "75.113.188.234 - - [09/Jan/2017:22:30:43 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 1116",
                "69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] \"GET /pages/create HTTP/1.0\" 500 3471",
                "225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 500 2477",
                "207.243.19.2 - - [09/Jan/2017:22:38:03 +0100] \"GET /bar/create HTTP/1.0\" 200 1116",
                "199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] \"GET /posts/1/display HTTP/1.0\" 200 2477",
                "251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 2477",
                "200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 3471"
            ]
        }
    },
    {
        "slug": "search_for_files_containing_string",
        "emoji": "emojis/1F41E",
        "disp_title": "search for string",
        "version": 6,
        "author": "cmdchallenge",
        "description": "Imprimir todos los archivos en el directorio actual, uno por línea (no la ruta, solo el nombre del archivo) que contengan la cadena \"500\".\n",
        "completions": [
            "access.log"
        ],
        "example": "grep -l 500 *",
        "expected_failures": [
            "ls *[^2]"
        ],
        "expected_output": {
            "order": false,
            "lines": [
                "access.log",
                "access.log.1"
            ]
        }
    },
    {
        "slug": "search_for_files_by_extension",
        "emoji": "emojis/1F997",
        "disp_title": "search for extension",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprimir las rutas de archivo relativas, una ruta por línea para todos los nombres de archivo que comiencen con \"access.log\" en el directorio actual.\n",
        "completions": [
            "access.log"
        ],
        "example": "find . -name 'access.log*'",
        "expected_output": {
            "order": false,
            "re_sub": [
                "^\\./",
                ""
            ],
            "lines": [
                "access.log",
                "access.log.1",
                "access.log.2"
            ]
        }
    },
    {
        "slug": "search_for_string_in_files_recursive",
        "emoji": "emojis/1F577",
        "disp_title": "search recursive",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprime todas las líneas coincidentes (sin el nombre ni la ruta del archivo) en todos los archivos del directorio actual que comiencen con \"access.log\" y que contengan la cadena \"500\".\n\nTen en cuenta que no hay archivos llamados `access.log` en el directorio actual; deberás buscar de forma recursiva.\n",
        "completions": [
            "access.log"
        ],
        "example": "grep -h 500 **/access.log*",
        "expected_output": {
            "order": false,
            "lines": [
                "69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] \"GET /pages/create HTTP/1.0\" 500 3471",
                "225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 500 2477",
                "2.71.250.27 - - [09/Jan/2017:22:41:26 +0100] \"GET /pages/create HTTP/1.0\" 500 2477"
            ]
        }
    },
    {
        "slug": "extract_ip_addresses",
        "emoji": "emojis/1F982",
        "disp_title": "find ip address",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Extrae todas las direcciones IP de los archivos que comienzan con \"access.log\" imprimiendo una dirección IP por línea.\n",
        "completions": [
            "access.log"
        ],
        "example": "grep -Pho '^\\d+\\.\\d+\\.\\d+\\.\\d+' **/access.log*",
        "expected_output": {
            "re_sub": [
                "^[\\w/.]*?:",
                ""
            ],
            "order": false,
            "lines": [
                "163.56.115.58",
                "75.113.188.234",
                "69.16.40.148",
                "225.219.54.140",
                "207.243.19.2",
                "199.37.62.156",
                "55.74.240.123",
                "251.111.109.143",
                "101.163.230.250",
                "200.19.168.148",
                "108.68.174.15",
                "17.2.20.139",
                "28.151.137.59",
                "199.150.241.179",
                "2.71.250.27",
                "17.137.186.194",
                "151.84.119.34",
                "4.180.204.195",
                "9.230.96.54",
                "157.143.233.21"
            ]
        }
    },
    {
        "slug": "count_files",
        "emoji": "emojis/1FAB0",
        "disp_title": "count files",
        "version": 8,
        "author": "cmdchallenge",
        "description": "Cuenta la cantidad de archivos en el directorio de trabajo actual. Imprime la cantidad de archivos como un solo entero.\n",
        "example": "find -L . -type f | wc -l",
        "expected_failures": [
            "echo 2"
        ],
        "expected_output": {
            "re_sub": [
                "^\\s+",
                ""
            ],
            "lines": [
                "2"
            ]
        }
    },
    {
        "slug": "simple_sort",
        "emoji": "emojis/1FAB1",
        "disp_title": "simple sort",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprimir el contenido de access.log ordenado.\n",
        "completions": [
            "access.log"
        ],
        "example": "sort access.log",
        "expected_output": {
            "lines": [
                "101.163.230.250 - - [09/Jan/2017:22:52:31 +0100] \"DELETE /posts/2/display HTTP/1.0\" 404 2477",
                "163.56.115.58 - - [09/Jan/2017:22:29:57 +0100] \"GET /posts/2/display HTTP/1.0\" 200 3240",
                "199.37.62.156 - - [09/Jan/2017:22:42:18 +0100] \"GET /posts/1/display HTTP/1.0\" 200 2477",
                "200.19.168.148 - - [09/Jan/2017:22:57:11 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 3471",
                "207.243.19.2 - - [09/Jan/2017:22:38:03 +0100] \"GET /bar/create HTTP/1.0\" 200 1116",
                "225.219.54.140 - - [09/Jan/2017:22:35:30 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 500 2477",
                "251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 2477",
                "55.74.240.123 - - [09/Jan/2017:22:44:25 +0100] \"POST /posts/1/display HTTP/1.0\" 200 3471",
                "69.16.40.148 - - [09/Jan/2017:22:34:33 +0100] \"GET /pages/create HTTP/1.0\" 500 3471",
                "75.113.188.234 - - [09/Jan/2017:22:30:43 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 1116"
            ]
        }
    },
    {
        "slug": "count_string_in_line",
        "emoji": "emojis/1F9A0",
        "disp_title": "count the strings",
        "version": 6,
        "author": "cmdchallenge",
        "description": "Imprime el número de líneas en access.log que contienen la cadena \"GET\".\n",
        "completions": [
            "access.log"
        ],
        "example": "grep -c \"GET\" access.log",
        "expected_failures": [
            "echo 8"
        ],
        "expected_output": {
            "re_sub": [
                "^\\s+",
                ""
            ],
            "lines": [
                "8"
            ]
        }
    },
    {
        "slug": "split_on_a_char",
        "emoji": "emojis/1F435",
        "disp_title": "split on a char",
        "version": 5,
        "author": "cmdchallenge",
        "description": "El archivo split-me.txt contiene una lista de números separados por un carácter `;`.\n\nSepara los números uno por línea.\n",
        "completions": [
            "split-me.txt"
        ],
        "example": "tr ';' '\\n' < split-me.txt",
        "expected_output": {
            "lines": [
                "1",
                "2",
                "3",
                "4",
                "5",
                "6",
                "7",
                "8",
                "9",
                "10"
            ]
        }
    },
    {
        "slug": "print_number_sequence",
        "emoji": "emojis/1F436",
        "disp_title": "generate a number sequence",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprime los números del 1 al 100 separados por espacios.\n",
        "example": "echo $(seq 1 100)",
        "expected_output": {
            "lines": [
                "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100"
            ]
        }
    },
    {
        "slug": "replace_text_in_files",
        "emoji": "emojis/1F98A",
        "disp_title": "replace text in files",
        "version": 6,
        "author": "cmdchallenge",
        "example": "sed -i 's/challenges are difficult//g' **/*.txt",
        "expected_failures": [
            "echo"
        ],
        "description": "Este desafío contiene archivos de texto (con extensión .txt) que contienen la frase \"challenges are difficult\". Elimine esta frase de todos los archivos de texto recursivamente.\n\nTenga en cuenta que algunos archivos están en subdirectorios, por lo que deberá buscarlos.\n"
    },
    {
        "slug": "sum_all_numbers",
        "emoji": "emojis/1F431",
        "disp_title": "sum the numbers",
        "version": 6,
        "author": "cmdchallenge",
        "example": "paste -sd+ sum-me.txt | bc",
        "expected_failures": [
            "echo 42"
        ],
        "description": "El archivo sum-me.txt contiene una lista de números, uno por línea. Imprima la suma de estos números.\n",
        "expected_output": {
            "lines": [
                "42"
            ]
        }
    },
    {
        "slug": "just_the_files",
        "emoji": "emojis/1F981",
        "disp_title": "only the filenames",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprimir todos los archivos en el directorio actual recursivamente sin la ruta del directorio principal.\n",
        "example": "find -type f -printf '%f\\n'",
        "expected_output": {
            "order": false,
            "lines": [
                "animi.doc",
                "corporis.xls",
                "odit.doc",
                "beatae.flac",
                "error.doc",
                "libero.xls",
                "necessitatibus.doc",
                "totam"
            ]
        }
    },
    {
        "slug": "remove_extensions_from_files",
        "emoji": "emojis/1F42F",
        "disp_title": "remove extensions",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Renombrar todos los archivos eliminando la extensión de los mismos en el directorio actual de forma recursiva.\n",
        "example": "for f in $(find . -type f -name \"*.*\"); do mv \"$f\" \"${f%.*}\"; done",
        "expected_failures": [
            "echo"
        ]
    },
    {
        "slug": "replace_spaces_in_filenames",
        "emoji": "emojis/1F434",
        "disp_title": "replace spaces",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Los archivos en este desafío contienen espacios.\nEnumera todos los archivos (solo nombres de archivo) en el directorio actual, pero reemplaza todos los espacios con el carácter '.'.\n",
        "example": "ls | tr ' ' '.'",
        "expected_output": {
            "order": false,
            "lines": [
                "Adam.Simpson",
                "Alexis.Stein",
                "Allison.Brown",
                "Amy.Anderson",
                "Angel.Saunders",
                "Brad.Michael",
                "Briana.Wilson",
                "Carrie.Alexander",
                "Christine.Valdez",
                "Christopher.Miller",
                "Claudia.Mccormick",
                "Corey.Bird",
                "Courtney.Miller",
                "Crystal.Dunn",
                "Crystal.Valdez",
                "Erica.Richardson",
                "James.Harper",
                "James.Roberts",
                "Jared.Hill.DVM",
                "John.Nguyen",
                "Jorge.Ross",
                "Joseph.Hurst",
                "Karen.Ramirez",
                "Kevin.Price",
                "Kimberly.Parker",
                "Lori.Macias",
                "Luke.Mason",
                "Lynn.Robinson",
                "Mallory.Peterson",
                "Marie.Gutierrez",
                "Matthew.Romero",
                "Michaela.Hobbs",
                "Molly.Stevens",
                "Mr..James.Lopez",
                "Mr..Shawn.Martin",
                "Mrs..Jade.Clark",
                "Olivia.Irwin",
                "Parker.Gilbert",
                "Robert.Gregory",
                "Robert.Hill",
                "Sarah.Hill",
                "Scott.Rice",
                "Sheri.Bishop",
                "Tamara.Anderson",
                "Tammy.Galloway",
                "Terri.Young",
                "Thomas.Parks",
                "Thomas.Washington",
                "Tiffany.Clark",
                "Yvonne.Myers"
            ]
        }
    },
    {
        "slug": "dirs_containing_files_with_extension",
        "emoji": "emojis/1F984",
        "disp_title": "directories containing files",
        "version": 2,
        "author": "cmdchallenge",
        "description": "En este desafío hay algunos directorios que contienen archivos con diferentes extensiones.\nImprime todos los directorios, uno por línea sin duplicados, que contengan uno o más archivos con la extensión \".tf\".\n",
        "completions": [
            "terraform",
            "main.tf",
            "modules",
            "load_balancer",
            "main.tf",
            "virtual_machine",
            "outputs.tf",
            "main.tf",
            "vpn",
            "main.tf",
            "files",
            "bootstrap.sh",
            "templates",
            "config.template",
            "bin",
            "dostuff.sh"
        ],
        "example": "find . -name \"*.tf\" -type f -exec dirname {} \\; | sort | uniq",
        "expected_output": {
            "order": false,
            "re_sub": [
                "^\\./",
                ""
            ],
            "lines": [
                "terraform",
                "terraform/modules/load_balancer",
                "terraform/modules/virtual_machine",
                "terraform/modules/vpn"
            ]
        }
    },
    {
        "slug": "files_starting_with_a_number",
        "emoji": "emojis/1F42E",
        "disp_title": "files starting with a number",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Hay una mezcla de archivos en este directorio que comienzan con letras y números.\nImprime los nombres de archivo (solo los nombres de archivo) de todos los archivos que comienzan con un número de forma recursiva en el directorio actual.\n",
        "completions": [
            "757Robert Marquez",
            "Mr. James Lopez",
            "974Michael Bowman",
            "477Thomas Pierce MD",
            "04Carrie Alexander",
            "42Robert Hill",
            "737Jeffrey Davis",
            "778Holly Archer",
            "402Nancy Henson",
            "436Teresa Owens",
            "48Thomas Allen",
            "001dir",
            "exercitationem.mp3",
            "3maxime.mp3",
            "Jorge Ross",
            "540Katherine Jones",
            "682Terri Jones",
            "639Charles Ferguson",
            "25Brandon Mcdonald",
            "132Rebecca Rubio",
            "78Michelle Spencer",
            "Matthew Romero",
            "670James Jacobs",
            "dir",
            "provident.avi",
            "99blanditiis.avi",
            "sit.avi",
            "nisi.avi",
            "totam.avi",
            "293Linda Bennett",
            "335John Joseph",
            "593Brett Martin",
            "388Andrew Carter",
            "tmp",
            "511Tammy Welch",
            "Sheri Bishop"
        ],
        "example": "find . -type f -name '[[:digit:]]*' -printf '%f\\n'",
        "expected_output": {
            "order": false,
            "lines": [
                "974Michael Bowman",
                "540Katherine Jones",
                "436Teresa Owens",
                "04Carrie Alexander",
                "778Holly Archer",
                "3maxime.mp3",
                "682Terri Jones",
                "511Tammy Welch",
                "293Linda Bennett",
                "670James Jacobs",
                "737Jeffrey Davis",
                "42Robert Hill",
                "25Brandon Mcdonald",
                "402Nancy Henson",
                "78Michelle Spencer",
                "132Rebecca Rubio",
                "639Charles Ferguson",
                "335John Joseph",
                "99blanditiis.avi",
                "477Thomas Pierce MD",
                "757Robert Marquez",
                "388Andrew Carter",
                "48Thomas Allen",
                "593Brett Martin"
            ]
        }
    },
    {
        "slug": "print_nth_line",
        "emoji": "emojis/1F437",
        "disp_title": "nth line",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprimir la línea 25 del archivo faces.txt\n",
        "example": "sed -n '25p' faces.txt",
        "expected_output": {
            "lines": [
                "¯\\_(ツ)_/¯"
            ]
        }
    },
    {
        "slug": "reverse_readme",
        "emoji": "emojis/1F42D",
        "disp_title": "reverse",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprime las líneas del archivo `reverse-me.txt` en este directorio en orden inverso, de modo que la última línea se imprima primero y la primera linea, al final.\n\n```\n~~~~~~~~~~~~~~~~~~~~~\nIn the future\nEnvironmental destruction will be the norm\nNo longer can it be said that\nMy peers and I care about this earth\nIt will be evident that\nMy generation is apathetic and lethargic\nIt is foolish to presume that\nThere is hope\n~~~~~~~~~~~~~~~~~~~~~\n-Jonathan Reed \"The Lost Generation\"\n```\n",
        "example": "tac reverse-me.txt",
        "expected_output": {
            "lines": [
                "-Jonathan Reed \"The Lost Generation\"",
                "~~~~~~~~~~~~~~~~~~~~~",
                "There is hope",
                "It is foolish to presume that",
                "My generation is apathetic and lethargic",
                "It will be evident that",
                "My peers and I care about this earth",
                "No longer can it be said that",
                "Environmental destruction will be the norm",
                "In the future",
                "~~~~~~~~~~~~~~~~~~~~~"
            ]
        }
    },
    {
        "slug": "remove_duplicate_lines",
        "emoji": "emojis/1F439",
        "disp_title": "remove duplicates",
        "version": 5,
        "author": "cmdchallenge",
        "description": "Imprime el archivo faces.txt, pero solo imprime la primera instancia de cada línea duplicada, incluso si los duplicados no aparecen uno al lado del otro.\n\nTen en cuenta que el orden importa, así que no ordenes las líneas antes de eliminar los duplicados.\n",
        "example": "awk '!x[$0]++' faces.txt",
        "expected_output": {
            "lines": [
                "(◕‿◕)",
                "(^̮^)",
                "ʘ‿ʘ",
                "ಠ_ಠ",
                "ಠ⌣ಠ",
                "ಠ‿ಠ",
                "(ʘ‿ʘ)",
                "(ಠ_ಠ)",
                "¯\\_(ツ)_/¯",
                "(ಠ⌣ಠ",
                "ಠಠ⌣ಠ)",
                "(ಠ‿ಠ)",
                "٩◔̯◔۶",
                "ヽ༼ຈل͜ຈ༽ﾉ",
                "♥‿♥",
                "◔̯◔",
                "⊙﹏⊙",
                "(¬_¬)",
                "(；一_一)",
                "(͡° ͜ʖ ͡°)",
                "(° ͜ʖ °)",
                "¯\\(°_o)/¯",
                "( ﾟヮﾟ)",
                "(︺︹︺)"
            ]
        }
    },
    {
        "slug": "find_primes",
        "emoji": "emojis/1F43B",
        "disp_title": "finding prime numbers",
        "version": 2,
        "author": "cmdchallenge",
        "example": "for num in $(cat random-numbers.txt); do [[ $num == $(factor $num | cut -d\" \" -f2) ]] && echo $num; done | sort | uniq | wc -l",
        "expected_failures": [
            "echo 12"
        ],
        "completions": [
            "random-numbers.txt"
        ],
        "description": "El archivo `random-numbers.txt` contiene una lista de 100 números enteros aleatorios.\nImprime la cantidad de números primos únicos contenidos en el archivo.\n",
        "expected_output": {
            "lines": [
                "12"
            ]
        }
    },
    {
        "slug": "print_common_lines",
        "emoji": "emojis/1F43C",
        "version": 5,
        "author": "amboar",
        "disp_title": "print common lines",
        "example": "comm -12 <(cut -d' ' -f1 access.log.1 | sort) <(cut -d' ' -f1 access.log.2 | sort)",
        "completions": [
            "access.log.1",
            "access.log.2"
        ],
        "description": "`access.log.1` y `access.log.2` son registros del servidor http.\n\nImprime las direcciones IP comunes a ambos archivos, una por línea.\n",
        "expected_output": {
            "order": false,
            "lines": [
                "108.68.174.15",
                "17.137.186.194",
                "2.71.250.27",
                "28.151.137.59"
            ]
        }
    },
    {
        "slug": "print_line_before",
        "emoji": "emojis/1F423",
        "disp_title": "print line before match",
        "version": 5,
        "author": "mmr",
        "example": "awk '/404/{print a}{a=$0}' **/access.log*",
        "description": "Imprime todas las líneas coincidentes (sin el nombre ni la ruta del archivo) en todos los archivos del directorio actual que comiencen con \"access.log\", donde la siguiente línea contenga la cadena \"404\".\n\nTen en cuenta que deberás buscar de forma recursiva.\n",
        "completions": [
            "access.log"
        ],
        "expected_output": {
            "order": false,
            "lines": [
                "251.111.109.143 - - [09/Jan/2017:22:49:02 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 2477",
                "17.137.186.194 - - [09/Jan/2017:22:43:17 +0100] \"GET /pages/create HTTP/1.0\" 200 1116",
                "89.148.148.238 - - [09/Jan/2017:22:33:09 +0100] \"GET /posts/1/display HTTP/1.0\" 502 2477",
                "138.212.253.84 - - [09/Jan/2017:22:53:54 +0100] \"GET /posts/foo?appID=xxxx HTTP/1.0\" 200 3471"
            ]
        }
    },
    {
        "slug": "print_files_if_different",
        "emoji": "emojis/1F99A",
        "version": 5,
        "author": "anonymous",
        "disp_title": "files that are different",
        "example": "for i in $(ls *.bin); do if [[ `cmp base.bin $i` ]]; then echo $i; fi; done",
        "description": "Imprimir todos los archivos con extensión `.bin` en el directorio actual que sean diferentes al archivo llamado base.bin.\n",
        "expected_output": {
            "order": false,
            "lines": [
                "test2.bin",
                "test4.bin",
                "test5.bin",
                "test7.bin"
            ]
        }
    },
    {
        "slug": "nested_dirs",
        "emoji": "emojis/1F438",
        "disp_title": "tricky file",
        "version": 6,
        "author": "gitunique",
        "description": "\nHay un archivo: `./.../ /. .the flag.txt`\n\n Muestra su contenido en la pantalla.\n",
        "example": "cat ./.../\\ \\ /.\\ .the\\ flag.txt",
        "expected_failures": [
            "echo you got it!"
        ],
        "expected_output": {
            "lines": [
                "you got it!"
            ]
        }
    },
    {
        "slug": "find_tabs_in_a_file",
        "emoji": "emojis/1F432",
        "version": 6,
        "disp_title": "find tabs in file",
        "author": "anonymous",
        "description": "¿Cuántas líneas contienen caracteres de tabulación en el archivo llamado `file-with-tabs.txt` en el directorio actual.\n",
        "example": "grep -P '\\t' file-with-tabs.txt | wc -l",
        "expected_failures": [
            "echo 3"
        ],
        "expected_output": {
            "lines": [
                "3"
            ]
        }
    },
    {
        "slug": "remove_files_without_extension",
        "emoji": "emojis/1F338",
        "version": 5,
        "author": "bryfry",
        "disp_title": "Remove files without extension.",
        "description": "Hay archivos en este desafío con diferentes extensiones.\n\nElimine todos los archivos sin las extensiones .txt y .exe de forma recursiva en el directorio de trabajo actual.\n",
        "example": "find . -type f -regextype posix-extended ! -regex \".*(\\.txt|\\.exe)$\" -exec rm {} +",
        "expected_failures": [
            "echo"
        ]
    },
    {
        "slug": "remove_files_with_a_dash",
        "emoji": "emojis/1F339",
        "version": 5,
        "author": "anonymous",
        "disp_title": "Remove files that start with a dash",
        "description": "Hay algunos archivos en este directorio que comienzan con un guion en el nombre del archivo. Elimine esos archivos.\n",
        "example": "rm ./-*",
        "expected_failures": [
            "echo"
        ]
    },
    {
        "slug": "print_sorted_by_key",
        "emoji": "emojis/1F33A",
        "version": 5,
        "author": "verovan",
        "disp_title": "Print the content sorted by PID",
        "description": "Hay dos archivos en este directorio, ps-ef1 y ps-ef2. Imprima el contenido de ambos archivos ordenados por PID y elimine las líneas repetidas.\n",
        "example": "cat ps-ef1 > aux; sed '1 d' ps-ef2 >> aux; cat aux | sort -nk2,2 | uniq",
        "expected_output": {
            "lines": [
                "UID        PID  PPID  C STIME TTY          TIME CMD",
                "root         1     0  0 mar04 ?        00:00:13 /sbin/init",
                "root         2     0  0 mar04 ?        00:00:00 [kthreadd]",
                "root         3     2  0 mar04 ?        00:01:07 [ksoftirqd/0]",
                "user         5     2  0 mar04 ?        00:00:00 [kworker/0:0H]",
                "user         7     2  0 mar04 ?        00:07:06 [rcu_sched]",
                "user         8     2  0 mar04 ?        00:00:00 [rcu_bh]",
                "root         9     2  0 mar04 ?        00:00:00 [migration/0]",
                "root        10     2  0 mar04 ?        00:00:04 [watchdog/0]",
                "user        11     2  0 mar04 ?        00:00:04 [watchdog/1]",
                "root        12     2  0 mar04 ?        00:00:00 [migration/1]",
                "root        13     2  0 mar04 ?        00:00:59 [ksoftirqd/1]",
                "user        15     2  0 mar04 ?        00:00:00 [kworker/1:0H]",
                "user        16     2  0 mar04 ?        00:00:04 [watchdog/2]",
                "root        17     2  0 mar04 ?        00:00:00 [migration/2]",
                "root        18     2  0 mar04 ?        00:00:59 [ksoftirqd/2]",
                "root        20     2  0 mar04 ?        00:00:00 [kworker/2:0H]",
                "user        21     2  0 mar04 ?        00:00:04 [watchdog/3]",
                "root        22     2  0 mar04 ?        00:00:00 [migration/3]",
                "root        23     2  0 mar04 ?        00:01:29 [ksoftirqd/3]"
            ]
        }
    },
    {
        "slug": "IPv4_listening_ports",
        "emoji": "emojis/1F33B",
        "version": 5,
        "author": "TaTo69",
        "disp_title": "print the ports",
        "description": "En el directorio actual hay un archivo llamado netstat.out.\n\nImprime todos los puertos de escucha IPv4 ordenados de mayor a menor.\n",
        "example": "egrep  \"tcp\\ .*:**LISTEN\" netstat.out | awk '{print $4}' | sed -e 's/.*\\://g' | sort -nr",
        "expected_output": {
            "lines": [
                "45922",
                "9090",
                "8080",
                "1723",
                "1254",
                "1244",
                "1234",
                "111",
                "80",
                "22"
            ]
        }
    }
]